#pragma config(Sensor, in1,    ,               sensorGyro)
#pragma config(Sensor, dgtl2,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftMotor,     tmotorNone, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define sr SensorValue
#define mtr motor


//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
int first_gyro = 450;//first gyro turn(shooting position - home base)
int pick1_gyro = 650;//turn to pick up first stack
int face_gyro = 450;//face the net;
int move1 = 800;
int turn1 = 150;
int move2 = 4562;

void straight()
{
	if(sr[rightEncoder] == sr[leftEncoder]) // If rightEncoder has counted the same amount as leftEncoder:
	{
		// Move Forward
		motor[rightMotor] = -110;		    // Right Motor is run at power level 80
		motor[leftMotor]  = -110;		    // Left Motor is run at power level 80
	}
	else if(sr[rightEncoder] > sr[leftEncoder])	// If rightEncoder has counted more encoder counts
	{
		// Turn slightly right
		motor[rightMotor] = -108;		    // Right Motor is run at power level 60
		motor[leftMotor]  = -110;		    // Left Motor is run at power level 80
	}
	else	// Only runs if leftEncoder has counted more encoder counts
	{
		// Turn slightly left
		motor[rightMotor] = -110;		    // Right Motor is run at power level 80
		motor[leftMotor]  = -108;		    // Left Motor is run at power level 60
	}
}


void gyro_turn(int my_turn)
{
  	//While the absolute value of the gyro is less than the desired rotation - 100...
  	while(abs(SensorValue[in1]) < my_turn - 100)
  	{
    //...Continue turning
    	motor[rightMotor] = 50;
    	motor[leftMotor] = -50;
  	}
  	//Brief brake to eliminate some drift
  	motor[rightMotor] = -5;
  	motor[leftMotor] = 5;
  	wait1Msec(100);

  	//Second while loop to move more slowly toward the goal
  	while(abs(SensorValue[in1]) != my_turn)
  	{
    	if(abs(SensorValue[in1]) > my_turn)
    	{
      	motor[rightMotor] = -30;
      	motor[leftMotor] = 30;
    	}
    	else
    	{
      	motor[rightMotor] = 30;
      	motor[leftMotor] = -30;
    	}
  	}
  	//Stop
  	motor[rightMotor] = 0;
  	motor[leftMotor] = 0;
  	wait1Msec(250);
}




task main()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
  SensorType[in1] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in1] = sensorGyro;
  wait1Msec(2000);
	sr[rightEncoder]=0;
	sr[leftEncoder]=0;
	wait1Msec(2000);

	{

		gyro_turn(first_gyro);
		wait1Msec(1000);
		gyro_turn(pick1_gyro);

		//move before turn
		while(sr[rightEncoder] < move1)
		{
			straight();
		}

		{
			mtr[rightMotor]=0;
			mtr[leftMotor]=0;
		}

		gyro_turn(face_gyro);

		/*sr[rightEncoder]=0;
		sr[leftEncoder]=0;
		wait1Msec(2000);
		//turn 1(use gyro)
		while(sr[leftEncoder] < turn1)
		{
			mtr[rightMotor]=-63;
			mtr[leftMotor]=63;
		}

		{
			mtr[rightMotor]=0;
			mtr[leftMotor]=0;
		}*/

		sr[rightEncoder]=0;
		sr[leftEncoder]=0;
		wait1Msec(1000);

		//move 2
		while(sr[leftEncoder] < move2)
		{
			straight();
		}

		{
			mtr[rightMotor]=0;
			mtr[leftMotor]=0;
		}
	}
}
