#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           h_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           d_left,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           y_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           motor1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           motor2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           motor3,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           motor4,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           y_left,        tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port9,           d_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          v_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define sr nMotorEncoder
#define mtr motor


//Specify the number of degrees for the robot to turn (1 degree = 10, or 900 = 90 degrees)
int first_gyro = 450;//first gyro turn(shooting position - home base)
int pick1_gyro = 650;//turn to pick up first stack
int face_gyro = 450;//face the net;
int move1 = 800;
int turn1 = 150;
int move2 = 4562;

void leftdrive(int speed)
{
	mtr[d_left]=speed;
	mtr[y_left]=speed;
}

void rightdrive(int speed)
{
	mtr[d_right]=speed;
	mtr[y_right]=speed;
}

void straight()
{
	if(sr[rightEncoder] == sr[leftEncoder]) // If rightEncoder has counted the same amount as leftEncoder:
	{
		// Move Forward
		rightdrive(-110);		    // Right Motor is run at power level 80
		leftdrive(-110);		    // Left Motor is run at power level 80
	}
	else if(sr[rightEncoder] > sr[leftEncoder])	// If rightEncoder has counted more encoder counts
	{
		// Turn slightly right
		rightdrive(-110);		    // Right Motor is run at power level 60
		leftdrive(-115);		    // Left Motor is run at power level 80
	}
	else	// Only runs if leftEncoder has counted more encoder counts
	{
		// Turn slightly left
		rightdrive(-115);
		leftdrive(-110);
	}
}


void gyro_turn(int my_turn)
{
  	//While the absolute value of the gyro is less than the desired rotation - 100...
  	while(abs(SensorValue[in1]) < my_turn - 100)
  	{
    //...Continue turning
    	rightdrive(50);
			leftdrive(-50);
  	}
  	//Brief brake to eliminate some drift
  	rightdrive(-5);
		leftdrive(5);
  	wait1Msec(100);

  	//Second while loop to move more slowly toward the goal
  	while(abs(SensorValue[in1]) != my_turn)
  	{
    	if(abs(SensorValue[in1]) > my_turn)
    	{
      	rightdrive(-30);
				leftdrive(30);
    	}
    	else
    	{
      	rightdrive(30);
				leftdrive(-30);
    	}
  	}
  	//Stop
  	rightdrive(0);
		leftdrive(0);
  	wait1Msec(250);
}




task main()
{
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
  SensorType[in1] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in1] = sensorGyro;
  wait1Msec(2000);
	sr[y_right]=0;
	sr[y_left]=0;
	wait1Msec(2000);

	{

		//gyro_turn(first_gyro);
		wait1Msec(1000);
		gyro_turn(pick1_gyro);

		//move before turn
		while(sr[rightEncoder] < move1)
		{
			straight();
		}

		{
			rightdrive(0);
			leftdrive(0);
		}

		gyro_turn(face_gyro);

		/*sr[rightEncoder]=0;
		sr[leftEncoder]=0;
		wait1Msec(2000);
		//turn 1(use gyro)
		while(sr[leftEncoder] < turn1)
		{
			mtr[rightMotor]=-63;
			mtr[leftMotor]=63;
		}

		{
			mtr[rightMotor]=0;
			mtr[leftMotor]=0;
		}*/

		rightdrive(0);
		leftdrive(0);
		wait1Msec(1000);

		//move 2
		while(sr[leftEncoder] < move2)
		{
			straight();
		}

		{
			rightdrive(0);
			leftdrive(0);
		}
	}
}
