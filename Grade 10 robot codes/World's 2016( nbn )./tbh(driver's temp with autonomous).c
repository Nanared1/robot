#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    ,               sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           h_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           d_left,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           y_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           motor1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           motor2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           motor3,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           motor4,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           y_left,        tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           d_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          v_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////


const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

void rightdrive(int speed)
{
	motor[d_right]=speed;
	motor[y_right]=speed;
}
void leftdrive(int speed)
{
	motor[d_left]=speed;
	motor[y_left]=speed;
}

void straight()
{
	if(nMotorEncoder[y_right] == nMotorEncoder[y_left]) // If rightEncoder has counted the same amount as leftEncoder:
	{
		// Move Forward
		rightdrive(110);		    // Right Motor is run at power level 80
		leftdrive(110);		    // Left Motor is run at power level 80
	}
	else if(nMotorEncoder[y_right] > nMotorEncoder[y_left])	// If rightEncoder has counted more encoder counts
	{
		// Turn slightly right
		rightdrive(110);		    // Right Motor is run at power level 60
		leftdrive(115);		    // Left Motor is run at power level 80
	}
	else	// Only runs if leftEncoder has counted more encoder counts
	{
		// Turn slightly left
		rightdrive(115);
		leftdrive(110);
	}
}

void gyro_turnBLUE( int degrees10)
{
while(abs(SensorValue[in8]) < degrees10 - 100)
  {
    //...Continue turning
    rightdrive(-100);
    leftdrive(100);
  }
  //Brief brake to eliminate some drift
  rightdrive(5);
  leftdrive(-5);
  wait1Msec(100);

  //Second while loop to move more slowly toward the goal
  while(abs(SensorValue[in8]) != degrees10)
  {
    if(abs(SensorValue[in8]) > degrees10)
    {
      rightdrive(30);
      leftdrive(-30);
    }
    else
    {
      rightdrive(-30);
      leftdrive(30);
    }
  }
  //Stop
  rightdrive(0);
      leftdrive(0);
  wait1Msec(250);
}


void gyro_turnRED( int degrees10)
{
while(abs(SensorValue[in8]) < degrees10 - 100)
  {
    //...Continue turning
    rightdrive(100);
    leftdrive(-100);
  }
  //Brief brake to eliminate some drift
  rightdrive(-5);
  leftdrive(5);
  wait1Msec(100);

  //Second while loop to move more slowly toward the goal
  while(abs(SensorValue[in8]) != degrees10)
  {
    if(abs(SensorValue[in8]) > degrees10)
    {
      rightdrive(-30);
      leftdrive(30);
    }
    else
    {
      rightdrive(30);
      leftdrive(-30);
    }
  }
  //Stop
  rightdrive(0);
      leftdrive(0);
  wait1Msec(250);
}
void shoot(int speed)
{
	motor[motor1]=speed;
	motor[motor2]=speed;
	motor[motor3]=speed;
	motor[motor4]=speed;
}


// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller {
    long            counter;                ///< loop counter used for debug

    // encoder tick per revolution
    float           ticks_per_rev;          ///< encoder ticks per revolution

    // Encoder
    long            e_current;              ///< current encoder count
    long            e_last;                 ///< current encoder count

    // velocity measurement
    float           v_current;              ///< current velocity in rpm
    long            v_time;                 ///< Time of last velocity calculation

    // TBH control algorithm variables
    long            target;                 ///< target velocity
    long            current;                ///< current velocity
    long            last;                   ///< last velocity
    float           error;                  ///< error between actual and target velocities
    float           last_error;             ///< error last time update called
    float           gain;                   ///< gain
    float           drive;                  ///< final drive out of TBH (0.0 to 1.0)
    float           drive_at_zero;          ///< drive at last zero crossing
    long            first_cross;            ///< flag indicating first zero crossing
    float           drive_approx;           ///< estimated open loop drive

    // final motor drive
    long            motor_drive;            ///< final motor control value
    } fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwMotorSet( int value )
{
    motor[ motor1 ] = value;
    motor[ motor2 ] = value;
    motor[ motor3 ] = value;
    motor[ motor4 ] = value;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwMotorEncoderGet()
{
    return( abs(nMotorEncoder[ motor3 ]) );
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
    // set target velocity (motor rpm)
    fw->target        = velocity;

    // Set error so zero crossing is correctly detected
    fw->error         = fw->target - fw->current;
    fw->last_error    = fw->error;

    // Set predicted open loop drive value
    fw->drive_approx  = predicted_drive;
    // Set flag to detect first zero crossing
    fw->first_cross   = 1;
    // clear tbh variable
    fw->drive_at_zero = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwCalculateSpeed( fw_controller *fw )
{
    int     delta_ms;
    int     delta_enc;

    // Get current encoder value
    fw->e_current = FwMotorEncoderGet();

    // This is just used so we don't need to know how often we are called
    // how many mS since we were last here
    delta_ms   = nSysTime - fw->v_time;
    fw->v_time = nSysTime;

    // Change in encoder count
    delta_enc = (fw->e_current - fw->e_last);

    // save last position
    fw->e_last = fw->e_current;

    // Calculate velocity in rpm
    fw->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fw->ticks_per_rev;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwControlUpdateVelocityTbh( fw_controller *fw )
{
    // calculate error in velocity
    // target is desired velocity
    // current is measured velocity
    fw->error = fw->target - fw->current;

    // Use Kp as gain
    fw->drive =  fw->drive + (fw->error * fw->gain);

    // Clip - we are only going forwards
    if( fw->drive > 1 )
          fw->drive = 1;
    if( fw->drive < 0 )
          fw->drive = 0;

    // Check for zero crossing
    if( sgn(fw->error) != sgn(fw->last_error) ) {
        // First zero crossing after a new set velocity command
        if( fw->first_cross ) {
            // Set drive to the open loop approximation
            fw->drive = fw->drive_approx;
            fw->first_cross = 0;
        }
        else
            fw->drive = 0.5 * ( fw->drive + fw->drive_at_zero );

        // Save this drive value in the "tbh" variable
        fw->drive_at_zero = fw->drive;
    }

    // Save last error
    fw->last_error = fw->error;
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the flywheel                    */
/*-----------------------------------------------------------------------------*/
task
FwControlTask()
{
    fw_controller *fw = &flywheel;

    // Set the gain
    fw->gain = 0.0025;

    // We are using Speed geared motors
    // Set the encoder ticks per revolution
    fw->ticks_per_rev = MOTOR_TPR_393R;

    while(1)
        {
        // debug counter
        fw->counter++;

        // Calculate velocity
        FwCalculateSpeed( fw );

        // Set current speed for the tbh calculation code
        fw->current = fw->v_current;

        // Do the velocity TBH calculations
        FwControlUpdateVelocityTbh( fw ) ;

        // Scale drive into the range the motors need
        fw->motor_drive  = (fw->drive * FW_MAX_POWER) + 0.5;

        // Final Limit of motor values - don't really need this
        if( fw->motor_drive >  127 ) fw->motor_drive =  127;
        if( fw->motor_drive < -127 ) fw->motor_drive = -127;

        // and finally set the motor control value
        FwMotorSet( fw->motor_drive );

        // Run at somewhere between 20 and 50mS
        wait1Msec( FW_LOOP_SPEED );
        }
}

//Declare count variable to keep track of our choice
	int count = 0;

void pre_auton()
{


	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Setup(red 1)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Setup (red 2)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Autonomous 3");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Setup(BLUE 1)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
	//------------- End of User Interface Code ---------------------
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


task autonomous()
{
  //slight turn to the right
	SensorType[in8] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in8] = sensorGyro;
  nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
  wait1Msec(2000);


	//------------- Beginning of Robot Movement Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Setup(red 1)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		while(abs(nMotorEncoder[y_left]) < 5)
	{
		leftdrive(75);
		rightdrive(0);
	}
	leftdrive(0);
	rightdrive(0);

	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnRED(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnRED(400);

	while(abs(nMotorEncoder[y_right]) < 2700)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Setup (red 2)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		{
		//gyro_turn(70);
	leftdrive(0);
	rightdrive(0);
	}
	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(115);
		rightdrive(95);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	//gyro_turn(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnRED(400);

	while(abs(nMotorEncoder[y_right]) < 2700)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}

	//leftdrive(127);
	//rightdrive(127);
	//wait1Msec(2000);
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Setup(Blue 2)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		//Turn right for 3 seconds
		{
		//gyro_turn(70);
	leftdrive(0);
	rightdrive(0);
	}
	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(95);
		rightdrive(115);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnBLUE(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnBLUE(350);

	while(abs(nMotorEncoder[y_right]) < 1900)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Setup(BLUE 1)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		{
		//gyro_turn(70);
		//leftdrive(0);
		rightdrive(75);
		wait1Msec(100);
	}
	leftdrive(0);
	rightdrive(0);

	nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnBLUE(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnBLUE(320);

	while(abs(nMotorEncoder[y_left]) < 2400)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	//------------- End of Robot Movement Code -----------------------
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


task usercontrol()
{
		char  str[32];

    bLCDBacklight = true;

    // Start the flywheel control task
    startTask( FwControlTask );

    // Main user control loop
    while(1)
        {

        motor[d_left]=vexRT(Ch3);
				motor[d_right]=vexRT(Ch2);
				motor[y_left]=vexRT(Ch3);
				motor[y_right]=vexRT(Ch2);


		if( vexRT[ Btn6DXmtr2 ] == 1 )
        FwVelocitySet( &flywheel, 145, 0.7 );
    if( vexRT[ Btn6UXmtr2 ] == 1 )
        FwVelocitySet( &flywheel, 200, 0.95 );
    if( vexRT[ Btn5UXmtr2 ] == 1 )
        FwVelocitySet( &flywheel, 94, 0.31 );
    if( vexRT[ Btn5DXmtr2 ] == 1 )
        FwVelocitySet( &flywheel, 0, 0 );



        if(vexRT[Btn7UXmtr2] == true)
				{
					motor[h_intake] = 127;
				}
				else if(vexRT[Btn7DXmtr2] == true)
				{
					motor[h_intake] = -127;
				}
				else
				{
					motor[h_intake] = 0;
				}



				if(vexRT[Btn8UXmtr2] == true)
				{
					motor[v_intake] = 127;
				}
				else if(vexRT[Btn8DXmtr2] == true)
				{
					motor[v_intake] = -127;
				}
				else
				{
					motor[v_intake] = 0;
				}


        // Display useful things on the LCD
        sprintf( str, "%4d %4d  %5.2f", flywheel.target,  flywheel.current, nImmediateBatteryLevel/1000.0 );
        displayLCDString(0, 0, str );
        sprintf( str, "%4.2f %4.2f ", flywheel.drive, flywheel.drive_at_zero );
        displayLCDString(1, 0, str );

        // Don't hog the cpu :)
        wait1Msec(10);
        }
}
