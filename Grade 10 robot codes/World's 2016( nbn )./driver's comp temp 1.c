#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in8,    ,               sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  leftEncoder,    sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  rightEncoder,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           h_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           d_left,        tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           y_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port4,           motor1,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           motor2,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           motor3,        tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           motor4,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           y_left,        tmotorVex393TurboSpeed_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port9,           d_right,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          v_intake,      tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  // Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;

//Wait for Press--------------------------------------------------
void waitForPress()
{
	while(nLCDButtons == 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

//Wait for Release------------------------------------------------
void waitForRelease()
{
	while(nLCDButtons != 0){}
	wait1Msec(5);
}
//----------------------------------------------------------------

void rightdrive(int speed)
{
	motor[d_right]=speed;
	motor[y_right]=speed;
}
void leftdrive(int speed)
{
	motor[d_left]=speed;
	motor[y_left]=speed;
}

void straight()
{
	if(nMotorEncoder[y_right] == nMotorEncoder[y_left]) // If rightEncoder has counted the same amount as leftEncoder:
	{
		// Move Forward
		rightdrive(110);		    // Right Motor is run at power level 80
		leftdrive(110);		    // Left Motor is run at power level 80
	}
	else if(nMotorEncoder[y_right] > nMotorEncoder[y_left])	// If rightEncoder has counted more encoder counts
	{
		// Turn slightly right
		rightdrive(110);		    // Right Motor is run at power level 60
		leftdrive(115);		    // Left Motor is run at power level 80
	}
	else	// Only runs if leftEncoder has counted more encoder counts
	{
		// Turn slightly left
		rightdrive(115);
		leftdrive(110);
	}
}

void gyro_turnBLUE( int degrees10)
{
while(abs(SensorValue[in8]) < degrees10 - 100)
  {
    //...Continue turning
    rightdrive(-100);
    leftdrive(100);
  }
  //Brief brake to eliminate some drift
  rightdrive(5);
  leftdrive(-5);
  wait1Msec(100);

  //Second while loop to move more slowly toward the goal
  while(abs(SensorValue[in8]) != degrees10)
  {
    if(abs(SensorValue[in8]) > degrees10)
    {
      rightdrive(30);
      leftdrive(-30);
    }
    else
    {
      rightdrive(-30);
      leftdrive(30);
    }
  }
  //Stop
  rightdrive(0);
      leftdrive(0);
  wait1Msec(250);
}


void gyro_turnRED( int degrees10)
{
while(abs(SensorValue[in8]) < degrees10 - 100)
  {
    //...Continue turning
    rightdrive(100);
    leftdrive(-100);
  }
  //Brief brake to eliminate some drift
  rightdrive(-5);
  leftdrive(5);
  wait1Msec(100);

  //Second while loop to move more slowly toward the goal
  while(abs(SensorValue[in8]) != degrees10)
  {
    if(abs(SensorValue[in8]) > degrees10)
    {
      rightdrive(-30);
      leftdrive(30);
    }
    else
    {
      rightdrive(30);
      leftdrive(-30);
    }
  }
  //Stop
  rightdrive(0);
      leftdrive(0);
  wait1Msec(250);
}
void shoot(int speed)
{
	motor[motor1]=speed;
	motor[motor2]=speed;
	motor[motor3]=speed;
	motor[motor4]=speed;
}

task autonomous()
{
  //slight turn to the right
	SensorType[in8] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in8] = sensorGyro;
  nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
  wait1Msec(2000);
	//Declare count variable to keep track of our choice
	int count = 0;

	//------------- Beginning of User Interface Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Loop while center button is not pressed
	while(nLCDButtons != centerButton)
	{
		//Switch case that allows the user to choose from 4 different options
		switch(count){
		case 0:
			//Display first choice
			displayLCDCenteredString(0, "Setup(red 1)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count = 3;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 1:
			//Display second choice
			displayLCDCenteredString(0, "Setup (red 2)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 2:
			//Display third choice
			displayLCDCenteredString(0, "Autonomous 3");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count++;
			}
			break;
		case 3:
			//Display fourth choice
			displayLCDCenteredString(0, "Setup(BLUE 1)");
			displayLCDCenteredString(1, "<		 Enter		>");
			waitForPress();
			//Increment or decrement "count" based on button press
			if(nLCDButtons == leftButton)
			{
				waitForRelease();
				count--;
			}
			else if(nLCDButtons == rightButton)
			{
				waitForRelease();
				count = 0;
			}
			break;
		default:
			count = 0;
			break;
		}
	}
	//------------- End of User Interface Code ---------------------

	//------------- Beginning of Robot Movement Code ---------------
	//Clear LCD
	clearLCDLine(0);
	clearLCDLine(1);
	//Switch Case that actually runs the user choice
	switch(count){
	case 0:
		//If count = 0, run the code correspoinding with choice 1
		displayLCDCenteredString(0, "Setup(red 1)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		while(abs(nMotorEncoder[y_left]) < 5)
	{
		leftdrive(75);
		rightdrive(0);
	}
	leftdrive(0);
	rightdrive(0);

	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnRED(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnRED(400);

	while(abs(nMotorEncoder[y_right]) < 2700)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	case 1:
		//If count = 1, run the code correspoinding with choice 2
		displayLCDCenteredString(0, "Setup (red 2)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		{
		//gyro_turn(70);
	leftdrive(0);
	rightdrive(0);
	}
	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(115);
		rightdrive(95);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	//gyro_turn(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnRED(400);

	while(abs(nMotorEncoder[y_right]) < 2700)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}

	//leftdrive(127);
	//rightdrive(127);
	//wait1Msec(2000);
		break;
	case 2:
		//If count = 2, run the code correspoinding with choice 3
		displayLCDCenteredString(0, "Setup(Blue 2)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		//Turn right for 3 seconds
		{
		//gyro_turn(70);
	leftdrive(0);
	rightdrive(0);
	}
	//nMotorEncoder[y_left]=0;
	//nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(95);
		rightdrive(115);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnBLUE(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnBLUE(350);

	while(abs(nMotorEncoder[y_right]) < 1900)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	case 3:
		//If count = 3, run the code correspoinding with choice 4
		displayLCDCenteredString(0, "Setup(BLUE 1)");
		displayLCDCenteredString(1, "is running!");
		wait1Msec(2000);						// Robot waits for 2000 milliseconds

		{
		//gyro_turn(70);
		//leftdrive(0);
		rightdrive(75);
		wait1Msec(100);
	}
	leftdrive(0);
	rightdrive(0);

	nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	//move up
	while(abs(nMotorEncoder[y_right]) < 470)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
	leftdrive(0);
	rightdrive(0);
	wait1Msec(1000);
	gyro_turnBLUE(700);
	}

	/*nMotorEncoder[y_left]=0;
	nMotorEncoder[y_right]=0;
	while(nMotorEncoder[y_left] < 10)
	{
		leftdrive(50);
		rightdrive(-50);
	}
	leftdrive(0);
	rightdrive(0);*/

	wait1Msec(1000);

	gyro_turnBLUE(320);

	while(abs(nMotorEncoder[y_left]) < 2400)
	{
		leftdrive(100);
		rightdrive(100);
	}
	{
		leftdrive(0);
		rightdrive(0);
	}
		break;
	default:
		displayLCDCenteredString(0, "No valid choice");
		displayLCDCenteredString(1, "was made!");
		break;
	}
	//------------- End of Robot Movement Code -----------------------
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


task usercontrol()
{
	while(true)
	{
		motor[d_left]=vexRT(Ch3);
		motor[d_right]=vexRT(Ch2);
		motor[y_left]=vexRT(Ch3);
		motor[y_right]=vexRT(Ch2);

		if(vexRT[Btn5DXmtr2] == true)
		{
			shoot(0);
		}
		if(vexRT[Btn5UXmtr2] == true)
		{
			shoot(80);
		}
		if(vexRT[Btn6DXmtr2] == true)
		{
			shoot(65);
		}
		if(vexRT[Btn6UXmtr2] == true)
		{
			shoot(125);
		}


		if(vexRT[Btn7UXmtr2] == true)
		{
			motor[h_intake] = 127;
		}
		else if(vexRT[Btn7DXmtr2] == true)
		{
			motor[h_intake] = -127;
		}
		else
		{
			motor[h_intake] = 0;
		}



		if(vexRT[Btn8UXmtr2] == true)
		{
			motor[v_intake] = 127;
		}
		else if(vexRT[Btn8DXmtr2] == true)
		{
			motor[v_intake] = -127;
		}
		else
		{
			motor[v_intake] = 0;
		}


	}
}
